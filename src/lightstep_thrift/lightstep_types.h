/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef lightstep_TYPES_H
#define lightstep_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace lightstep_thrift {

class KeyValue;

class NamedCounter;

class Runtime;

class LogRecord;

class TraceJoinId;

class SpanRecord;

class Auth;

class Timing;

class SampleCount;

class ReportRequest;

class Command;

class ReportResponse;


class KeyValue : public virtual ::apache::thrift::TBase {
 public:

  KeyValue(const KeyValue&);
  KeyValue(KeyValue&&);
  KeyValue& operator=(const KeyValue&);
  KeyValue& operator=(KeyValue&&);
  KeyValue() : Key(), Value() {
  }

  virtual ~KeyValue() throw();
  std::string Key;
  std::string Value;

  void __set_Key(const std::string& val);

  void __set_Value(const std::string& val);

  bool operator == (const KeyValue & rhs) const
  {
    if (!(Key == rhs.Key))
      return false;
    if (!(Value == rhs.Value))
      return false;
    return true;
  }
  bool operator != (const KeyValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KeyValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(KeyValue &a, KeyValue &b);

inline std::ostream& operator<<(std::ostream& out, const KeyValue& obj)
{
  obj.printTo(out);
  return out;
}


class NamedCounter : public virtual ::apache::thrift::TBase {
 public:

  NamedCounter(const NamedCounter&);
  NamedCounter(NamedCounter&&);
  NamedCounter& operator=(const NamedCounter&);
  NamedCounter& operator=(NamedCounter&&);
  NamedCounter() : Name(), Value(0) {
  }

  virtual ~NamedCounter() throw();
  std::string Name;
  int64_t Value;

  void __set_Name(const std::string& val);

  void __set_Value(const int64_t val);

  bool operator == (const NamedCounter & rhs) const
  {
    if (!(Name == rhs.Name))
      return false;
    if (!(Value == rhs.Value))
      return false;
    return true;
  }
  bool operator != (const NamedCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NamedCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NamedCounter &a, NamedCounter &b);

inline std::ostream& operator<<(std::ostream& out, const NamedCounter& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Runtime__isset {
  _Runtime__isset() : guid(false), start_micros(false), group_name(false), attrs(false) {}
  bool guid :1;
  bool start_micros :1;
  bool group_name :1;
  bool attrs :1;
} _Runtime__isset;

class Runtime : public virtual ::apache::thrift::TBase {
 public:

  Runtime(const Runtime&);
  Runtime(Runtime&&);
  Runtime& operator=(const Runtime&);
  Runtime& operator=(Runtime&&);
  Runtime() : guid(), start_micros(0), group_name() {
  }

  virtual ~Runtime() throw();
  std::string guid;
  int64_t start_micros;
  std::string group_name;
  std::vector<KeyValue>  attrs;

  _Runtime__isset __isset;

  void __set_guid(const std::string& val);

  void __set_start_micros(const int64_t val);

  void __set_group_name(const std::string& val);

  void __set_attrs(const std::vector<KeyValue> & val);

  bool operator == (const Runtime & rhs) const
  {
    if (__isset.guid != rhs.__isset.guid)
      return false;
    else if (__isset.guid && !(guid == rhs.guid))
      return false;
    if (__isset.start_micros != rhs.__isset.start_micros)
      return false;
    else if (__isset.start_micros && !(start_micros == rhs.start_micros))
      return false;
    if (__isset.group_name != rhs.__isset.group_name)
      return false;
    else if (__isset.group_name && !(group_name == rhs.group_name))
      return false;
    if (__isset.attrs != rhs.__isset.attrs)
      return false;
    else if (__isset.attrs && !(attrs == rhs.attrs))
      return false;
    return true;
  }
  bool operator != (const Runtime &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Runtime & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Runtime &a, Runtime &b);

inline std::ostream& operator<<(std::ostream& out, const Runtime& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _LogRecord__isset {
  _LogRecord__isset() : timestamp_micros(false), runtime_guid(false), span_guid(false), stable_name(false), message(false), level(false), thread_id(false), filename(false), line_number(false), stack_frames(false), payload_json(false), error_flag(false) {}
  bool timestamp_micros :1;
  bool runtime_guid :1;
  bool span_guid :1;
  bool stable_name :1;
  bool message :1;
  bool level :1;
  bool thread_id :1;
  bool filename :1;
  bool line_number :1;
  bool stack_frames :1;
  bool payload_json :1;
  bool error_flag :1;
} _LogRecord__isset;

class LogRecord : public virtual ::apache::thrift::TBase {
 public:

  LogRecord(const LogRecord&);
  LogRecord(LogRecord&&);
  LogRecord& operator=(const LogRecord&);
  LogRecord& operator=(LogRecord&&);
  LogRecord() : timestamp_micros(0), runtime_guid(), span_guid(), stable_name(), message(), level(), thread_id(0), filename(), line_number(0), payload_json(), error_flag(0) {
  }

  virtual ~LogRecord() throw();
  int64_t timestamp_micros;
  std::string runtime_guid;
  std::string span_guid;
  std::string stable_name;
  std::string message;
  std::string level;
  int64_t thread_id;
  std::string filename;
  int64_t line_number;
  std::vector<std::string>  stack_frames;
  std::string payload_json;
  bool error_flag;

  _LogRecord__isset __isset;

  void __set_timestamp_micros(const int64_t val);

  void __set_runtime_guid(const std::string& val);

  void __set_span_guid(const std::string& val);

  void __set_stable_name(const std::string& val);

  void __set_message(const std::string& val);

  void __set_level(const std::string& val);

  void __set_thread_id(const int64_t val);

  void __set_filename(const std::string& val);

  void __set_line_number(const int64_t val);

  void __set_stack_frames(const std::vector<std::string> & val);

  void __set_payload_json(const std::string& val);

  void __set_error_flag(const bool val);

  bool operator == (const LogRecord & rhs) const
  {
    if (__isset.timestamp_micros != rhs.__isset.timestamp_micros)
      return false;
    else if (__isset.timestamp_micros && !(timestamp_micros == rhs.timestamp_micros))
      return false;
    if (__isset.runtime_guid != rhs.__isset.runtime_guid)
      return false;
    else if (__isset.runtime_guid && !(runtime_guid == rhs.runtime_guid))
      return false;
    if (__isset.span_guid != rhs.__isset.span_guid)
      return false;
    else if (__isset.span_guid && !(span_guid == rhs.span_guid))
      return false;
    if (__isset.stable_name != rhs.__isset.stable_name)
      return false;
    else if (__isset.stable_name && !(stable_name == rhs.stable_name))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    if (__isset.level != rhs.__isset.level)
      return false;
    else if (__isset.level && !(level == rhs.level))
      return false;
    if (__isset.thread_id != rhs.__isset.thread_id)
      return false;
    else if (__isset.thread_id && !(thread_id == rhs.thread_id))
      return false;
    if (__isset.filename != rhs.__isset.filename)
      return false;
    else if (__isset.filename && !(filename == rhs.filename))
      return false;
    if (__isset.line_number != rhs.__isset.line_number)
      return false;
    else if (__isset.line_number && !(line_number == rhs.line_number))
      return false;
    if (__isset.stack_frames != rhs.__isset.stack_frames)
      return false;
    else if (__isset.stack_frames && !(stack_frames == rhs.stack_frames))
      return false;
    if (__isset.payload_json != rhs.__isset.payload_json)
      return false;
    else if (__isset.payload_json && !(payload_json == rhs.payload_json))
      return false;
    if (__isset.error_flag != rhs.__isset.error_flag)
      return false;
    else if (__isset.error_flag && !(error_flag == rhs.error_flag))
      return false;
    return true;
  }
  bool operator != (const LogRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LogRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LogRecord &a, LogRecord &b);

inline std::ostream& operator<<(std::ostream& out, const LogRecord& obj)
{
  obj.printTo(out);
  return out;
}


class TraceJoinId : public virtual ::apache::thrift::TBase {
 public:

  TraceJoinId(const TraceJoinId&);
  TraceJoinId(TraceJoinId&&);
  TraceJoinId& operator=(const TraceJoinId&);
  TraceJoinId& operator=(TraceJoinId&&);
  TraceJoinId() : TraceKey(), Value() {
  }

  virtual ~TraceJoinId() throw();
  std::string TraceKey;
  std::string Value;

  void __set_TraceKey(const std::string& val);

  void __set_Value(const std::string& val);

  bool operator == (const TraceJoinId & rhs) const
  {
    if (!(TraceKey == rhs.TraceKey))
      return false;
    if (!(Value == rhs.Value))
      return false;
    return true;
  }
  bool operator != (const TraceJoinId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TraceJoinId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TraceJoinId &a, TraceJoinId &b);

inline std::ostream& operator<<(std::ostream& out, const TraceJoinId& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SpanRecord__isset {
  _SpanRecord__isset() : span_guid(false), runtime_guid(false), span_name(false), join_ids(false), oldest_micros(false), youngest_micros(false), attributes(false), error_flag(false), log_records(false) {}
  bool span_guid :1;
  bool runtime_guid :1;
  bool span_name :1;
  bool join_ids :1;
  bool oldest_micros :1;
  bool youngest_micros :1;
  bool attributes :1;
  bool error_flag :1;
  bool log_records :1;
} _SpanRecord__isset;

class SpanRecord : public virtual ::apache::thrift::TBase {
 public:

  SpanRecord(const SpanRecord&);
  SpanRecord(SpanRecord&&);
  SpanRecord& operator=(const SpanRecord&);
  SpanRecord& operator=(SpanRecord&&);
  SpanRecord() : span_guid(), runtime_guid(), span_name(), oldest_micros(0), youngest_micros(0), error_flag(0) {
  }

  virtual ~SpanRecord() throw();
  std::string span_guid;
  std::string runtime_guid;
  std::string span_name;
  std::vector<TraceJoinId>  join_ids;
  int64_t oldest_micros;
  int64_t youngest_micros;
  std::vector<KeyValue>  attributes;
  bool error_flag;
  std::vector<LogRecord>  log_records;

  _SpanRecord__isset __isset;

  void __set_span_guid(const std::string& val);

  void __set_runtime_guid(const std::string& val);

  void __set_span_name(const std::string& val);

  void __set_join_ids(const std::vector<TraceJoinId> & val);

  void __set_oldest_micros(const int64_t val);

  void __set_youngest_micros(const int64_t val);

  void __set_attributes(const std::vector<KeyValue> & val);

  void __set_error_flag(const bool val);

  void __set_log_records(const std::vector<LogRecord> & val);

  bool operator == (const SpanRecord & rhs) const
  {
    if (__isset.span_guid != rhs.__isset.span_guid)
      return false;
    else if (__isset.span_guid && !(span_guid == rhs.span_guid))
      return false;
    if (__isset.runtime_guid != rhs.__isset.runtime_guid)
      return false;
    else if (__isset.runtime_guid && !(runtime_guid == rhs.runtime_guid))
      return false;
    if (__isset.span_name != rhs.__isset.span_name)
      return false;
    else if (__isset.span_name && !(span_name == rhs.span_name))
      return false;
    if (__isset.join_ids != rhs.__isset.join_ids)
      return false;
    else if (__isset.join_ids && !(join_ids == rhs.join_ids))
      return false;
    if (__isset.oldest_micros != rhs.__isset.oldest_micros)
      return false;
    else if (__isset.oldest_micros && !(oldest_micros == rhs.oldest_micros))
      return false;
    if (__isset.youngest_micros != rhs.__isset.youngest_micros)
      return false;
    else if (__isset.youngest_micros && !(youngest_micros == rhs.youngest_micros))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.error_flag != rhs.__isset.error_flag)
      return false;
    else if (__isset.error_flag && !(error_flag == rhs.error_flag))
      return false;
    if (__isset.log_records != rhs.__isset.log_records)
      return false;
    else if (__isset.log_records && !(log_records == rhs.log_records))
      return false;
    return true;
  }
  bool operator != (const SpanRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpanRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpanRecord &a, SpanRecord &b);

inline std::ostream& operator<<(std::ostream& out, const SpanRecord& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Auth__isset {
  _Auth__isset() : access_token(false) {}
  bool access_token :1;
} _Auth__isset;

class Auth : public virtual ::apache::thrift::TBase {
 public:

  Auth(const Auth&);
  Auth(Auth&&);
  Auth& operator=(const Auth&);
  Auth& operator=(Auth&&);
  Auth() : access_token() {
  }

  virtual ~Auth() throw();
  std::string access_token;

  _Auth__isset __isset;

  void __set_access_token(const std::string& val);

  bool operator == (const Auth & rhs) const
  {
    if (__isset.access_token != rhs.__isset.access_token)
      return false;
    else if (__isset.access_token && !(access_token == rhs.access_token))
      return false;
    return true;
  }
  bool operator != (const Auth &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Auth & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Auth &a, Auth &b);

inline std::ostream& operator<<(std::ostream& out, const Auth& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Timing__isset {
  _Timing__isset() : receive_micros(false), transmit_micros(false) {}
  bool receive_micros :1;
  bool transmit_micros :1;
} _Timing__isset;

class Timing : public virtual ::apache::thrift::TBase {
 public:

  Timing(const Timing&);
  Timing(Timing&&);
  Timing& operator=(const Timing&);
  Timing& operator=(Timing&&);
  Timing() : receive_micros(0), transmit_micros(0) {
  }

  virtual ~Timing() throw();
  int64_t receive_micros;
  int64_t transmit_micros;

  _Timing__isset __isset;

  void __set_receive_micros(const int64_t val);

  void __set_transmit_micros(const int64_t val);

  bool operator == (const Timing & rhs) const
  {
    if (__isset.receive_micros != rhs.__isset.receive_micros)
      return false;
    else if (__isset.receive_micros && !(receive_micros == rhs.receive_micros))
      return false;
    if (__isset.transmit_micros != rhs.__isset.transmit_micros)
      return false;
    else if (__isset.transmit_micros && !(transmit_micros == rhs.transmit_micros))
      return false;
    return true;
  }
  bool operator != (const Timing &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Timing & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Timing &a, Timing &b);

inline std::ostream& operator<<(std::ostream& out, const Timing& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SampleCount__isset {
  _SampleCount__isset() : oldest_micros(false), youngest_micros(false), count(false) {}
  bool oldest_micros :1;
  bool youngest_micros :1;
  bool count :1;
} _SampleCount__isset;

class SampleCount : public virtual ::apache::thrift::TBase {
 public:

  SampleCount(const SampleCount&);
  SampleCount(SampleCount&&);
  SampleCount& operator=(const SampleCount&);
  SampleCount& operator=(SampleCount&&);
  SampleCount() : oldest_micros(0), youngest_micros(0), count(0) {
  }

  virtual ~SampleCount() throw();
  int64_t oldest_micros;
  int64_t youngest_micros;
  int64_t count;

  _SampleCount__isset __isset;

  void __set_oldest_micros(const int64_t val);

  void __set_youngest_micros(const int64_t val);

  void __set_count(const int64_t val);

  bool operator == (const SampleCount & rhs) const
  {
    if (__isset.oldest_micros != rhs.__isset.oldest_micros)
      return false;
    else if (__isset.oldest_micros && !(oldest_micros == rhs.oldest_micros))
      return false;
    if (__isset.youngest_micros != rhs.__isset.youngest_micros)
      return false;
    else if (__isset.youngest_micros && !(youngest_micros == rhs.youngest_micros))
      return false;
    if (__isset.count != rhs.__isset.count)
      return false;
    else if (__isset.count && !(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const SampleCount &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SampleCount & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SampleCount &a, SampleCount &b);

inline std::ostream& operator<<(std::ostream& out, const SampleCount& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ReportRequest__isset {
  _ReportRequest__isset() : runtime(false), span_records(false), log_records(false), timestamp_offset_micros(false), oldest_micros(false), youngest_micros(false), counters(false) {}
  bool runtime :1;
  bool span_records :1;
  bool log_records :1;
  bool timestamp_offset_micros :1;
  bool oldest_micros :1;
  bool youngest_micros :1;
  bool counters :1;
} _ReportRequest__isset;

class ReportRequest : public virtual ::apache::thrift::TBase {
 public:

  ReportRequest(const ReportRequest&);
  ReportRequest(ReportRequest&&);
  ReportRequest& operator=(const ReportRequest&);
  ReportRequest& operator=(ReportRequest&&);
  ReportRequest() : timestamp_offset_micros(0), oldest_micros(0), youngest_micros(0) {
  }

  virtual ~ReportRequest() throw();
  Runtime runtime;
  std::vector<SpanRecord>  span_records;
  std::vector<LogRecord>  log_records;
  int64_t timestamp_offset_micros;
  int64_t oldest_micros;
  int64_t youngest_micros;
  std::vector<NamedCounter>  counters;

  _ReportRequest__isset __isset;

  void __set_runtime(const Runtime& val);

  void __set_span_records(const std::vector<SpanRecord> & val);

  void __set_log_records(const std::vector<LogRecord> & val);

  void __set_timestamp_offset_micros(const int64_t val);

  void __set_oldest_micros(const int64_t val);

  void __set_youngest_micros(const int64_t val);

  void __set_counters(const std::vector<NamedCounter> & val);

  bool operator == (const ReportRequest & rhs) const
  {
    if (__isset.runtime != rhs.__isset.runtime)
      return false;
    else if (__isset.runtime && !(runtime == rhs.runtime))
      return false;
    if (__isset.span_records != rhs.__isset.span_records)
      return false;
    else if (__isset.span_records && !(span_records == rhs.span_records))
      return false;
    if (__isset.log_records != rhs.__isset.log_records)
      return false;
    else if (__isset.log_records && !(log_records == rhs.log_records))
      return false;
    if (__isset.timestamp_offset_micros != rhs.__isset.timestamp_offset_micros)
      return false;
    else if (__isset.timestamp_offset_micros && !(timestamp_offset_micros == rhs.timestamp_offset_micros))
      return false;
    if (__isset.oldest_micros != rhs.__isset.oldest_micros)
      return false;
    else if (__isset.oldest_micros && !(oldest_micros == rhs.oldest_micros))
      return false;
    if (__isset.youngest_micros != rhs.__isset.youngest_micros)
      return false;
    else if (__isset.youngest_micros && !(youngest_micros == rhs.youngest_micros))
      return false;
    if (__isset.counters != rhs.__isset.counters)
      return false;
    else if (__isset.counters && !(counters == rhs.counters))
      return false;
    return true;
  }
  bool operator != (const ReportRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReportRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ReportRequest &a, ReportRequest &b);

inline std::ostream& operator<<(std::ostream& out, const ReportRequest& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Command__isset {
  _Command__isset() : disable(false) {}
  bool disable :1;
} _Command__isset;

class Command : public virtual ::apache::thrift::TBase {
 public:

  Command(const Command&);
  Command(Command&&);
  Command& operator=(const Command&);
  Command& operator=(Command&&);
  Command() : disable(0) {
  }

  virtual ~Command() throw();
  bool disable;

  _Command__isset __isset;

  void __set_disable(const bool val);

  bool operator == (const Command & rhs) const
  {
    if (__isset.disable != rhs.__isset.disable)
      return false;
    else if (__isset.disable && !(disable == rhs.disable))
      return false;
    return true;
  }
  bool operator != (const Command &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Command & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Command &a, Command &b);

inline std::ostream& operator<<(std::ostream& out, const Command& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ReportResponse__isset {
  _ReportResponse__isset() : commands(false), timing(false), errors(false) {}
  bool commands :1;
  bool timing :1;
  bool errors :1;
} _ReportResponse__isset;

class ReportResponse : public virtual ::apache::thrift::TBase {
 public:

  ReportResponse(const ReportResponse&);
  ReportResponse(ReportResponse&&);
  ReportResponse& operator=(const ReportResponse&);
  ReportResponse& operator=(ReportResponse&&);
  ReportResponse() {
  }

  virtual ~ReportResponse() throw();
  std::vector<Command>  commands;
  Timing timing;
  std::vector<std::string>  errors;

  _ReportResponse__isset __isset;

  void __set_commands(const std::vector<Command> & val);

  void __set_timing(const Timing& val);

  void __set_errors(const std::vector<std::string> & val);

  bool operator == (const ReportResponse & rhs) const
  {
    if (__isset.commands != rhs.__isset.commands)
      return false;
    else if (__isset.commands && !(commands == rhs.commands))
      return false;
    if (__isset.timing != rhs.__isset.timing)
      return false;
    else if (__isset.timing && !(timing == rhs.timing))
      return false;
    if (__isset.errors != rhs.__isset.errors)
      return false;
    else if (__isset.errors && !(errors == rhs.errors))
      return false;
    return true;
  }
  bool operator != (const ReportResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReportResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ReportResponse &a, ReportResponse &b);

inline std::ostream& operator<<(std::ostream& out, const ReportResponse& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
