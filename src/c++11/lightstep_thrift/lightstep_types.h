/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef lightstep_TYPES_H
#define lightstep_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace lightstep_thrift {

class KeyValue;

class NamedCounter;

class Runtime;

class LogRecord;

class TraceJoinId;

class SpanRecord;

class Auth;

class Timing;

class SampleCount;

class MetricsSample;

class Metrics;

class ReportRequest;

class Command;

class ReportResponse;


class KeyValue {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  KeyValue(const KeyValue&);
  KeyValue& operator=(const KeyValue&);
  KeyValue() : Key(), Value() {
  }

  virtual ~KeyValue() throw();
  std::string Key;
  std::string Value;

  void __set_Key(const std::string& val);

  void __set_Value(const std::string& val);

  bool operator == (const KeyValue & rhs) const
  {
    if (!(Key == rhs.Key))
      return false;
    if (!(Value == rhs.Value))
      return false;
    return true;
  }
  bool operator != (const KeyValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KeyValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const KeyValue& obj);
};

void swap(KeyValue &a, KeyValue &b);


class NamedCounter {
 public:

  static const char* ascii_fingerprint; // = "1CCCF6FC31CFD1D61BBBB1BAF3590620";
  static const uint8_t binary_fingerprint[16]; // = {0x1C,0xCC,0xF6,0xFC,0x31,0xCF,0xD1,0xD6,0x1B,0xBB,0xB1,0xBA,0xF3,0x59,0x06,0x20};

  NamedCounter(const NamedCounter&);
  NamedCounter& operator=(const NamedCounter&);
  NamedCounter() : Name(), Value(0) {
  }

  virtual ~NamedCounter() throw();
  std::string Name;
  int64_t Value;

  void __set_Name(const std::string& val);

  void __set_Value(const int64_t val);

  bool operator == (const NamedCounter & rhs) const
  {
    if (!(Name == rhs.Name))
      return false;
    if (!(Value == rhs.Value))
      return false;
    return true;
  }
  bool operator != (const NamedCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NamedCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const NamedCounter& obj);
};

void swap(NamedCounter &a, NamedCounter &b);

typedef struct _Runtime__isset {
  _Runtime__isset() : guid(false), start_micros(false), group_name(false), attrs(false) {}
  bool guid :1;
  bool start_micros :1;
  bool group_name :1;
  bool attrs :1;
} _Runtime__isset;

class Runtime {
 public:

  static const char* ascii_fingerprint; // = "3B4A5DBE0E7BC5BBB17C3223CBB0897F";
  static const uint8_t binary_fingerprint[16]; // = {0x3B,0x4A,0x5D,0xBE,0x0E,0x7B,0xC5,0xBB,0xB1,0x7C,0x32,0x23,0xCB,0xB0,0x89,0x7F};

  Runtime(const Runtime&);
  Runtime& operator=(const Runtime&);
  Runtime() : guid(), start_micros(0), group_name() {
  }

  virtual ~Runtime() throw();
  std::string guid;
  int64_t start_micros;
  std::string group_name;
  std::vector<KeyValue>  attrs;

  _Runtime__isset __isset;

  void __set_guid(const std::string& val);

  void __set_start_micros(const int64_t val);

  void __set_group_name(const std::string& val);

  void __set_attrs(const std::vector<KeyValue> & val);

  bool operator == (const Runtime & rhs) const
  {
    if (__isset.guid != rhs.__isset.guid)
      return false;
    else if (__isset.guid && !(guid == rhs.guid))
      return false;
    if (__isset.start_micros != rhs.__isset.start_micros)
      return false;
    else if (__isset.start_micros && !(start_micros == rhs.start_micros))
      return false;
    if (__isset.group_name != rhs.__isset.group_name)
      return false;
    else if (__isset.group_name && !(group_name == rhs.group_name))
      return false;
    if (__isset.attrs != rhs.__isset.attrs)
      return false;
    else if (__isset.attrs && !(attrs == rhs.attrs))
      return false;
    return true;
  }
  bool operator != (const Runtime &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Runtime & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Runtime& obj);
};

void swap(Runtime &a, Runtime &b);

typedef struct _LogRecord__isset {
  _LogRecord__isset() : timestamp_micros(false), runtime_guid(false), span_guid(false), stable_name(false), message(false), level(false), thread_id(false), filename(false), line_number(false), stack_frames(false), payload_json(false), error_flag(false) {}
  bool timestamp_micros :1;
  bool runtime_guid :1;
  bool span_guid :1;
  bool stable_name :1;
  bool message :1;
  bool level :1;
  bool thread_id :1;
  bool filename :1;
  bool line_number :1;
  bool stack_frames :1;
  bool payload_json :1;
  bool error_flag :1;
} _LogRecord__isset;

class LogRecord {
 public:

  static const char* ascii_fingerprint; // = "37332972DE3466A6AC560DAAF028987D";
  static const uint8_t binary_fingerprint[16]; // = {0x37,0x33,0x29,0x72,0xDE,0x34,0x66,0xA6,0xAC,0x56,0x0D,0xAA,0xF0,0x28,0x98,0x7D};

  LogRecord(const LogRecord&);
  LogRecord& operator=(const LogRecord&);
  LogRecord() : timestamp_micros(0), runtime_guid(), span_guid(), stable_name(), message(), level(), thread_id(0), filename(), line_number(0), payload_json(), error_flag(0) {
  }

  virtual ~LogRecord() throw();
  int64_t timestamp_micros;
  std::string runtime_guid;
  std::string span_guid;
  std::string stable_name;
  std::string message;
  std::string level;
  int64_t thread_id;
  std::string filename;
  int64_t line_number;
  std::vector<std::string>  stack_frames;
  std::string payload_json;
  bool error_flag;

  _LogRecord__isset __isset;

  void __set_timestamp_micros(const int64_t val);

  void __set_runtime_guid(const std::string& val);

  void __set_span_guid(const std::string& val);

  void __set_stable_name(const std::string& val);

  void __set_message(const std::string& val);

  void __set_level(const std::string& val);

  void __set_thread_id(const int64_t val);

  void __set_filename(const std::string& val);

  void __set_line_number(const int64_t val);

  void __set_stack_frames(const std::vector<std::string> & val);

  void __set_payload_json(const std::string& val);

  void __set_error_flag(const bool val);

  bool operator == (const LogRecord & rhs) const
  {
    if (__isset.timestamp_micros != rhs.__isset.timestamp_micros)
      return false;
    else if (__isset.timestamp_micros && !(timestamp_micros == rhs.timestamp_micros))
      return false;
    if (__isset.runtime_guid != rhs.__isset.runtime_guid)
      return false;
    else if (__isset.runtime_guid && !(runtime_guid == rhs.runtime_guid))
      return false;
    if (__isset.span_guid != rhs.__isset.span_guid)
      return false;
    else if (__isset.span_guid && !(span_guid == rhs.span_guid))
      return false;
    if (__isset.stable_name != rhs.__isset.stable_name)
      return false;
    else if (__isset.stable_name && !(stable_name == rhs.stable_name))
      return false;
    if (__isset.message != rhs.__isset.message)
      return false;
    else if (__isset.message && !(message == rhs.message))
      return false;
    if (__isset.level != rhs.__isset.level)
      return false;
    else if (__isset.level && !(level == rhs.level))
      return false;
    if (__isset.thread_id != rhs.__isset.thread_id)
      return false;
    else if (__isset.thread_id && !(thread_id == rhs.thread_id))
      return false;
    if (__isset.filename != rhs.__isset.filename)
      return false;
    else if (__isset.filename && !(filename == rhs.filename))
      return false;
    if (__isset.line_number != rhs.__isset.line_number)
      return false;
    else if (__isset.line_number && !(line_number == rhs.line_number))
      return false;
    if (__isset.stack_frames != rhs.__isset.stack_frames)
      return false;
    else if (__isset.stack_frames && !(stack_frames == rhs.stack_frames))
      return false;
    if (__isset.payload_json != rhs.__isset.payload_json)
      return false;
    else if (__isset.payload_json && !(payload_json == rhs.payload_json))
      return false;
    if (__isset.error_flag != rhs.__isset.error_flag)
      return false;
    else if (__isset.error_flag && !(error_flag == rhs.error_flag))
      return false;
    return true;
  }
  bool operator != (const LogRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LogRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const LogRecord& obj);
};

void swap(LogRecord &a, LogRecord &b);


class TraceJoinId {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TraceJoinId(const TraceJoinId&);
  TraceJoinId& operator=(const TraceJoinId&);
  TraceJoinId() : TraceKey(), Value() {
  }

  virtual ~TraceJoinId() throw();
  std::string TraceKey;
  std::string Value;

  void __set_TraceKey(const std::string& val);

  void __set_Value(const std::string& val);

  bool operator == (const TraceJoinId & rhs) const
  {
    if (!(TraceKey == rhs.TraceKey))
      return false;
    if (!(Value == rhs.Value))
      return false;
    return true;
  }
  bool operator != (const TraceJoinId &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TraceJoinId & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const TraceJoinId& obj);
};

void swap(TraceJoinId &a, TraceJoinId &b);

typedef struct _SpanRecord__isset {
  _SpanRecord__isset() : span_guid(false), trace_guid(false), runtime_guid(false), span_name(false), join_ids(false), oldest_micros(false), youngest_micros(false), attributes(false), error_flag(false), log_records(false) {}
  bool span_guid :1;
  bool trace_guid :1;
  bool runtime_guid :1;
  bool span_name :1;
  bool join_ids :1;
  bool oldest_micros :1;
  bool youngest_micros :1;
  bool attributes :1;
  bool error_flag :1;
  bool log_records :1;
} _SpanRecord__isset;

class SpanRecord {
 public:

  static const char* ascii_fingerprint; // = "9E0D1B6963B21C4DE0C6ADFE77E847FD";
  static const uint8_t binary_fingerprint[16]; // = {0x9E,0x0D,0x1B,0x69,0x63,0xB2,0x1C,0x4D,0xE0,0xC6,0xAD,0xFE,0x77,0xE8,0x47,0xFD};

  SpanRecord(const SpanRecord&);
  SpanRecord& operator=(const SpanRecord&);
  SpanRecord() : span_guid(), trace_guid(), runtime_guid(), span_name(), oldest_micros(0), youngest_micros(0), error_flag(0) {
  }

  virtual ~SpanRecord() throw();
  std::string span_guid;
  std::string trace_guid;
  std::string runtime_guid;
  std::string span_name;
  std::vector<TraceJoinId>  join_ids;
  int64_t oldest_micros;
  int64_t youngest_micros;
  std::vector<KeyValue>  attributes;
  bool error_flag;
  std::vector<LogRecord>  log_records;

  _SpanRecord__isset __isset;

  void __set_span_guid(const std::string& val);

  void __set_trace_guid(const std::string& val);

  void __set_runtime_guid(const std::string& val);

  void __set_span_name(const std::string& val);

  void __set_join_ids(const std::vector<TraceJoinId> & val);

  void __set_oldest_micros(const int64_t val);

  void __set_youngest_micros(const int64_t val);

  void __set_attributes(const std::vector<KeyValue> & val);

  void __set_error_flag(const bool val);

  void __set_log_records(const std::vector<LogRecord> & val);

  bool operator == (const SpanRecord & rhs) const
  {
    if (__isset.span_guid != rhs.__isset.span_guid)
      return false;
    else if (__isset.span_guid && !(span_guid == rhs.span_guid))
      return false;
    if (__isset.trace_guid != rhs.__isset.trace_guid)
      return false;
    else if (__isset.trace_guid && !(trace_guid == rhs.trace_guid))
      return false;
    if (__isset.runtime_guid != rhs.__isset.runtime_guid)
      return false;
    else if (__isset.runtime_guid && !(runtime_guid == rhs.runtime_guid))
      return false;
    if (__isset.span_name != rhs.__isset.span_name)
      return false;
    else if (__isset.span_name && !(span_name == rhs.span_name))
      return false;
    if (__isset.join_ids != rhs.__isset.join_ids)
      return false;
    else if (__isset.join_ids && !(join_ids == rhs.join_ids))
      return false;
    if (__isset.oldest_micros != rhs.__isset.oldest_micros)
      return false;
    else if (__isset.oldest_micros && !(oldest_micros == rhs.oldest_micros))
      return false;
    if (__isset.youngest_micros != rhs.__isset.youngest_micros)
      return false;
    else if (__isset.youngest_micros && !(youngest_micros == rhs.youngest_micros))
      return false;
    if (__isset.attributes != rhs.__isset.attributes)
      return false;
    else if (__isset.attributes && !(attributes == rhs.attributes))
      return false;
    if (__isset.error_flag != rhs.__isset.error_flag)
      return false;
    else if (__isset.error_flag && !(error_flag == rhs.error_flag))
      return false;
    if (__isset.log_records != rhs.__isset.log_records)
      return false;
    else if (__isset.log_records && !(log_records == rhs.log_records))
      return false;
    return true;
  }
  bool operator != (const SpanRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpanRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SpanRecord& obj);
};

void swap(SpanRecord &a, SpanRecord &b);

typedef struct _Auth__isset {
  _Auth__isset() : access_token(false) {}
  bool access_token :1;
} _Auth__isset;

class Auth {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  Auth(const Auth&);
  Auth& operator=(const Auth&);
  Auth() : access_token() {
  }

  virtual ~Auth() throw();
  std::string access_token;

  _Auth__isset __isset;

  void __set_access_token(const std::string& val);

  bool operator == (const Auth & rhs) const
  {
    if (__isset.access_token != rhs.__isset.access_token)
      return false;
    else if (__isset.access_token && !(access_token == rhs.access_token))
      return false;
    return true;
  }
  bool operator != (const Auth &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Auth & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Auth& obj);
};

void swap(Auth &a, Auth &b);

typedef struct _Timing__isset {
  _Timing__isset() : receive_micros(false), transmit_micros(false) {}
  bool receive_micros :1;
  bool transmit_micros :1;
} _Timing__isset;

class Timing {
 public:

  static const char* ascii_fingerprint; // = "0354D07C94CB8542872CA1277008860A";
  static const uint8_t binary_fingerprint[16]; // = {0x03,0x54,0xD0,0x7C,0x94,0xCB,0x85,0x42,0x87,0x2C,0xA1,0x27,0x70,0x08,0x86,0x0A};

  Timing(const Timing&);
  Timing& operator=(const Timing&);
  Timing() : receive_micros(0), transmit_micros(0) {
  }

  virtual ~Timing() throw();
  int64_t receive_micros;
  int64_t transmit_micros;

  _Timing__isset __isset;

  void __set_receive_micros(const int64_t val);

  void __set_transmit_micros(const int64_t val);

  bool operator == (const Timing & rhs) const
  {
    if (__isset.receive_micros != rhs.__isset.receive_micros)
      return false;
    else if (__isset.receive_micros && !(receive_micros == rhs.receive_micros))
      return false;
    if (__isset.transmit_micros != rhs.__isset.transmit_micros)
      return false;
    else if (__isset.transmit_micros && !(transmit_micros == rhs.transmit_micros))
      return false;
    return true;
  }
  bool operator != (const Timing &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Timing & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Timing& obj);
};

void swap(Timing &a, Timing &b);

typedef struct _SampleCount__isset {
  _SampleCount__isset() : oldest_micros(false), youngest_micros(false), count(false) {}
  bool oldest_micros :1;
  bool youngest_micros :1;
  bool count :1;
} _SampleCount__isset;

class SampleCount {
 public:

  static const char* ascii_fingerprint; // = "6952BA042A8F8C3F826B0B8BA3E58440";
  static const uint8_t binary_fingerprint[16]; // = {0x69,0x52,0xBA,0x04,0x2A,0x8F,0x8C,0x3F,0x82,0x6B,0x0B,0x8B,0xA3,0xE5,0x84,0x40};

  SampleCount(const SampleCount&);
  SampleCount& operator=(const SampleCount&);
  SampleCount() : oldest_micros(0), youngest_micros(0), count(0) {
  }

  virtual ~SampleCount() throw();
  int64_t oldest_micros;
  int64_t youngest_micros;
  int64_t count;

  _SampleCount__isset __isset;

  void __set_oldest_micros(const int64_t val);

  void __set_youngest_micros(const int64_t val);

  void __set_count(const int64_t val);

  bool operator == (const SampleCount & rhs) const
  {
    if (__isset.oldest_micros != rhs.__isset.oldest_micros)
      return false;
    else if (__isset.oldest_micros && !(oldest_micros == rhs.oldest_micros))
      return false;
    if (__isset.youngest_micros != rhs.__isset.youngest_micros)
      return false;
    else if (__isset.youngest_micros && !(youngest_micros == rhs.youngest_micros))
      return false;
    if (__isset.count != rhs.__isset.count)
      return false;
    else if (__isset.count && !(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const SampleCount &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SampleCount & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SampleCount& obj);
};

void swap(SampleCount &a, SampleCount &b);

typedef struct _MetricsSample__isset {
  _MetricsSample__isset() : int64_value(false), double_value(false) {}
  bool int64_value :1;
  bool double_value :1;
} _MetricsSample__isset;

class MetricsSample {
 public:

  static const char* ascii_fingerprint; // = "93B342D69A9BA047485CCB868DBCADEB";
  static const uint8_t binary_fingerprint[16]; // = {0x93,0xB3,0x42,0xD6,0x9A,0x9B,0xA0,0x47,0x48,0x5C,0xCB,0x86,0x8D,0xBC,0xAD,0xEB};

  MetricsSample(const MetricsSample&);
  MetricsSample& operator=(const MetricsSample&);
  MetricsSample() : name(), int64_value(0), double_value(0) {
  }

  virtual ~MetricsSample() throw();
  std::string name;
  int64_t int64_value;
  double double_value;

  _MetricsSample__isset __isset;

  void __set_name(const std::string& val);

  void __set_int64_value(const int64_t val);

  void __set_double_value(const double val);

  bool operator == (const MetricsSample & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (__isset.int64_value != rhs.__isset.int64_value)
      return false;
    else if (__isset.int64_value && !(int64_value == rhs.int64_value))
      return false;
    if (__isset.double_value != rhs.__isset.double_value)
      return false;
    else if (__isset.double_value && !(double_value == rhs.double_value))
      return false;
    return true;
  }
  bool operator != (const MetricsSample &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MetricsSample & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MetricsSample& obj);
};

void swap(MetricsSample &a, MetricsSample &b);

typedef struct _Metrics__isset {
  _Metrics__isset() : counts(false) {}
  bool counts :1;
} _Metrics__isset;

class Metrics {
 public:

  static const char* ascii_fingerprint; // = "5D3862399C1EC6A8C0A3D6587AF7DD49";
  static const uint8_t binary_fingerprint[16]; // = {0x5D,0x38,0x62,0x39,0x9C,0x1E,0xC6,0xA8,0xC0,0xA3,0xD6,0x58,0x7A,0xF7,0xDD,0x49};

  Metrics(const Metrics&);
  Metrics& operator=(const Metrics&);
  Metrics() {
  }

  virtual ~Metrics() throw();
  std::vector<MetricsSample>  counts;

  _Metrics__isset __isset;

  void __set_counts(const std::vector<MetricsSample> & val);

  bool operator == (const Metrics & rhs) const
  {
    if (__isset.counts != rhs.__isset.counts)
      return false;
    else if (__isset.counts && !(counts == rhs.counts))
      return false;
    return true;
  }
  bool operator != (const Metrics &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Metrics & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Metrics& obj);
};

void swap(Metrics &a, Metrics &b);

typedef struct _ReportRequest__isset {
  _ReportRequest__isset() : runtime(false), span_records(false), log_records(false), timestamp_offset_micros(false), oldest_micros(false), youngest_micros(false), counters(false), internal_logs(false), internal_metrics(false) {}
  bool runtime :1;
  bool span_records :1;
  bool log_records :1;
  bool timestamp_offset_micros :1;
  bool oldest_micros :1;
  bool youngest_micros :1;
  bool counters :1;
  bool internal_logs :1;
  bool internal_metrics :1;
} _ReportRequest__isset;

class ReportRequest {
 public:

  static const char* ascii_fingerprint; // = "14D9E9AFAC8FB27BBF735F691AEBBEC0";
  static const uint8_t binary_fingerprint[16]; // = {0x14,0xD9,0xE9,0xAF,0xAC,0x8F,0xB2,0x7B,0xBF,0x73,0x5F,0x69,0x1A,0xEB,0xBE,0xC0};

  ReportRequest(const ReportRequest&);
  ReportRequest& operator=(const ReportRequest&);
  ReportRequest() : timestamp_offset_micros(0), oldest_micros(0), youngest_micros(0) {
  }

  virtual ~ReportRequest() throw();
  Runtime runtime;
  std::vector<SpanRecord>  span_records;
  std::vector<LogRecord>  log_records;
  int64_t timestamp_offset_micros;
  int64_t oldest_micros;
  int64_t youngest_micros;
  std::vector<NamedCounter>  counters;
  std::vector<LogRecord>  internal_logs;
  Metrics internal_metrics;

  _ReportRequest__isset __isset;

  void __set_runtime(const Runtime& val);

  void __set_span_records(const std::vector<SpanRecord> & val);

  void __set_log_records(const std::vector<LogRecord> & val);

  void __set_timestamp_offset_micros(const int64_t val);

  void __set_oldest_micros(const int64_t val);

  void __set_youngest_micros(const int64_t val);

  void __set_counters(const std::vector<NamedCounter> & val);

  void __set_internal_logs(const std::vector<LogRecord> & val);

  void __set_internal_metrics(const Metrics& val);

  bool operator == (const ReportRequest & rhs) const
  {
    if (__isset.runtime != rhs.__isset.runtime)
      return false;
    else if (__isset.runtime && !(runtime == rhs.runtime))
      return false;
    if (__isset.span_records != rhs.__isset.span_records)
      return false;
    else if (__isset.span_records && !(span_records == rhs.span_records))
      return false;
    if (__isset.log_records != rhs.__isset.log_records)
      return false;
    else if (__isset.log_records && !(log_records == rhs.log_records))
      return false;
    if (__isset.timestamp_offset_micros != rhs.__isset.timestamp_offset_micros)
      return false;
    else if (__isset.timestamp_offset_micros && !(timestamp_offset_micros == rhs.timestamp_offset_micros))
      return false;
    if (__isset.oldest_micros != rhs.__isset.oldest_micros)
      return false;
    else if (__isset.oldest_micros && !(oldest_micros == rhs.oldest_micros))
      return false;
    if (__isset.youngest_micros != rhs.__isset.youngest_micros)
      return false;
    else if (__isset.youngest_micros && !(youngest_micros == rhs.youngest_micros))
      return false;
    if (__isset.counters != rhs.__isset.counters)
      return false;
    else if (__isset.counters && !(counters == rhs.counters))
      return false;
    if (__isset.internal_logs != rhs.__isset.internal_logs)
      return false;
    else if (__isset.internal_logs && !(internal_logs == rhs.internal_logs))
      return false;
    if (__isset.internal_metrics != rhs.__isset.internal_metrics)
      return false;
    else if (__isset.internal_metrics && !(internal_metrics == rhs.internal_metrics))
      return false;
    return true;
  }
  bool operator != (const ReportRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReportRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ReportRequest& obj);
};

void swap(ReportRequest &a, ReportRequest &b);

typedef struct _Command__isset {
  _Command__isset() : disable(false) {}
  bool disable :1;
} _Command__isset;

class Command {
 public:

  static const char* ascii_fingerprint; // = "BF054652DEF86253C2BEE7D947F167DD";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0x05,0x46,0x52,0xDE,0xF8,0x62,0x53,0xC2,0xBE,0xE7,0xD9,0x47,0xF1,0x67,0xDD};

  Command(const Command&);
  Command& operator=(const Command&);
  Command() : disable(0) {
  }

  virtual ~Command() throw();
  bool disable;

  _Command__isset __isset;

  void __set_disable(const bool val);

  bool operator == (const Command & rhs) const
  {
    if (__isset.disable != rhs.__isset.disable)
      return false;
    else if (__isset.disable && !(disable == rhs.disable))
      return false;
    return true;
  }
  bool operator != (const Command &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Command & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Command& obj);
};

void swap(Command &a, Command &b);

typedef struct _ReportResponse__isset {
  _ReportResponse__isset() : commands(false), timing(false), errors(false) {}
  bool commands :1;
  bool timing :1;
  bool errors :1;
} _ReportResponse__isset;

class ReportResponse {
 public:

  static const char* ascii_fingerprint; // = "F57E18FDCF08B4D4B17A83ACE0F460B4";
  static const uint8_t binary_fingerprint[16]; // = {0xF5,0x7E,0x18,0xFD,0xCF,0x08,0xB4,0xD4,0xB1,0x7A,0x83,0xAC,0xE0,0xF4,0x60,0xB4};

  ReportResponse(const ReportResponse&);
  ReportResponse& operator=(const ReportResponse&);
  ReportResponse() {
  }

  virtual ~ReportResponse() throw();
  std::vector<Command>  commands;
  Timing timing;
  std::vector<std::string>  errors;

  _ReportResponse__isset __isset;

  void __set_commands(const std::vector<Command> & val);

  void __set_timing(const Timing& val);

  void __set_errors(const std::vector<std::string> & val);

  bool operator == (const ReportResponse & rhs) const
  {
    if (__isset.commands != rhs.__isset.commands)
      return false;
    else if (__isset.commands && !(commands == rhs.commands))
      return false;
    if (__isset.timing != rhs.__isset.timing)
      return false;
    else if (__isset.timing && !(timing == rhs.timing))
      return false;
    if (__isset.errors != rhs.__isset.errors)
      return false;
    else if (__isset.errors && !(errors == rhs.errors))
      return false;
    return true;
  }
  bool operator != (const ReportResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReportResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ReportResponse& obj);
};

void swap(ReportResponse &a, ReportResponse &b);

} // namespace

#endif
